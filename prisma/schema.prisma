// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- Enums ---
// ... (Enums remain the same) ...
enum TenantStatus {
  ACTIVE
  SUSPENDED
  TRIAL
}

enum ProductType {
  STANDARD
  KIT
  BUNDLE
  SERVICE
}

enum LocationType {
  WAREHOUSE
  STORE
  VIRTUAL // e.g., for dropshipping or non-physical stock
}

enum InventoryTransactionType {
  PURCHASE_RECEIPT
  SALE
  ADJUSTMENT_IN // Positive adjustment
  ADJUSTMENT_OUT // Negative adjustment
  TRANSFER_OUT
  TRANSFER_IN
  CYCLE_COUNT
  RETURN_RESTOCK // Restocking from a return
  KIT_ASSEMBLY_CONSUME // Consuming components
  KIT_ASSEMBLY_PRODUCE // Producing kit
}

enum TransferStatus {
  PENDING
  IN_TRANSIT
  COMPLETED
  CANCELLED
}

enum PurchaseOrderStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  SENT
  PARTIALLY_RECEIVED
  FULLY_RECEIVED
  CANCELLED
}

enum OrderType {
  POS
  WEB
  PHONE
  MANUAL
}

enum OrderStatus {
  PENDING_PAYMENT // Initial state, or for deferred payment
  PROCESSING // Payment received, inventory allocated/picked
  SHIPPED // Relevant for non-POS orders
  COMPLETED // Transaction finished (picked up, shipped and delivered, etc.)
  CANCELLED
  RETURNED // Fully returned
  PARTIALLY_RETURNED
}

enum PaymentMethod {
  CASH
  CREDIT_CARD
  DEBIT_CARD
  GIFT_CARD
  STORE_CREDIT
  BANK_TRANSFER
  CHECK // Cheque
  OTHER
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
  PARTIALLY_REFUNDED
}

enum ReturnStatus {
  PENDING
  APPROVED // Return accepted
  COMPLETED // Refund/exchange processed, items restocked/discarded
  REJECTED
}

enum ReturnItemCondition {
  SELLABLE
  DAMAGED
  DEFECTIVE
  DISPOSED
}

enum PosSessionStatus {
  OPEN
  CLOSED // Shift ended, needs reconciliation
  RECONCILED // Counts verified
}

enum PosTransactionType {
  CASH_SALE // Cash received from sale
  CASH_REFUND // Cash given for refund
  PAY_IN // Adding cash to drawer (float)
  PAY_OUT // Removing cash from drawer (expenses, bank deposit)
}

enum NotificationType {
  EMAIL
  SMS
  SYSTEM // In-app notification
}

// --- Models ---

// Core & Tenancy
model Tenant {
  id            String       @id @default(uuid())
  name          String
  status        TenantStatus @default(ACTIVE)
  configuration Json?        @default("{}") // Tenant-level config overrides
  createdAt     DateTime     @default(now()) @map("created_at")
  updatedAt     DateTime     @updatedAt @map("updated_at")

  // Relations
  users                 User[]
  customFields          CustomFieldDefinition[]
  roles                 Role[]
  products              Product[]
  categories            Category[]
  locations             Location[]
  inventoryItems        InventoryItem[]
  inventoryTx           InventoryTransaction[]
  inventoryTransfers    InventoryTransfer[]
  inventoryAdjustments  InventoryAdjustment[]
  suppliers             Supplier[]
  purchaseOrders        PurchaseOrder[]
  customers             Customer[]
  customerGroups        CustomerGroup[]
  orders                Order[]
  posSessions           PosSession[]
  configurations        Configuration[]
  notificationTemplates NotificationTemplate[]
  auditLogs             AuditLog[]
  returns               Return[] // <<< Added this inverse relation

  // Relations removed from Tenant model as they are inferred via parent models now:
  // inventoryTransferItems InventoryTransferItem[] // Removed - Inferred via InventoryTransfer
  // inventoryAdjustmentItems InventoryAdjustmentItem[] // Removed - Inferred via InventoryAdjustment
  // purchaseOrderItems    PurchaseOrderItem[] // Removed - Inferred via PurchaseOrder
  // orderItems            OrderItem[] // Removed - Inferred via Order
  // payments              Payment[] // Removed - Inferred via Order
  // returnItems           ReturnItem[] // Removed - Inferred via Return
  // posSessionTransactions PosSessionTransaction[] // Removed - Inferred via PosSession

  @@map("tenants")
}

model CustomFieldDefinition {
  id         String   @id @default(uuid())
  tenantId   String   @map("tenant_id")
  entityType String   @map("entity_type") // e.g., 'product', 'customer', 'order'
  fieldKey   String   @map("field_key")
  label      String
  fieldType  String   @map("field_type") // e.g., 'text', 'number', 'date', 'boolean', 'select'
  options    Json? // For 'select' type
  isRequired Boolean  @default(false) @map("is_required")
  createdAt  DateTime @default(now()) @map("created_at")

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, entityType, fieldKey])
  @@index([tenantId])
  @@map("custom_field_definitions")
}

// --- Add Refresh Token Model ---
model RefreshToken {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  tokenHash String   @unique @map("token_hash") // Store hash of the token, not the token itself
  userAgent String?  @map("user_agent") // Optional: Associate with user agent
  ipAddress String?  @map("ip_address") // Optional: Associate with IP
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  revokedAt DateTime? @map("revoked_at") // Timestamp when token was revoked (e.g., logout, reuse detected)

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
  @@index([userId])
  @@index([expiresAt])
}


// --- Add Password Reset Token Model ---
model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  tokenHash String   @unique @map("token_hash") // Store hash of the reset token
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  usedAt    DateTime? @map("used_at")    // Timestamp when token was used

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_reset_tokens")
  @@index([userId])
  @@index([expiresAt])
}

// Users & Access Control
model User {
  id           String   @id @default(uuid())
  tenantId     String   @map("tenant_id")
  email        String   @unique
  passwordHash String   @map("password_hash")
  firstName    String?  @map("first_name")
  lastName     String?  @map("last_name")
  phoneNumber  String?  @map("phone_number")
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  tenant                Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  roles                 UserRole[] // Many-to-many relation via UserRole table
  createdPOs            PurchaseOrder[]        @relation("CreatedByUser")
  createdOrders         Order[]                @relation("CreatedByUser")
  processedPayments     Payment[]              @relation("ProcessedByUser")
  createdReturns        Return[]               @relation("CreatedByUser") // Name changed from ProcessedByUser for clarity based on Return model
  posSessions           PosSession[]           @relation("ManagedByUser")
  auditLogs             AuditLog[]             @relation("ActionByUser")
  inventoryTransactions InventoryTransaction[] @relation("PerformedByUser")
  inventoryAdjustments  InventoryAdjustment[]  @relation("CreatedByUser")
  inventoryTransfers    InventoryTransfer[]    @relation("CreatedByUser")
  refreshTokens         RefreshToken[]
  passwordResetTokens   PasswordResetToken[]

  @@index([tenantId])
  @@index([email])
  @@map("users")
}

model Role {
  id           String   @id @default(uuid())
  tenantId     String   @map("tenant_id")
  name         String
  description  String?
  isSystemRole Boolean  @default(false) @map("is_system_role") // Cannot be deleted by tenant
  createdAt    DateTime @default(now()) @map("created_at")

  tenant      Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  users       UserRole[] // Many-to-many relation via UserRole table
  permissions RolePermission[] // Many-to-many relation via RolePermission table

  @@unique([tenantId, name])
  @@index([tenantId])
  @@map("roles")
}

model Permission {
  id            String           @id @default(uuid())
  permissionKey String           @unique @map("permission_key") // e.g., 'product:create', 'order:read'
  description   String?
  roles         RolePermission[] // Many-to-many relation via RolePermission table

  @@map("permissions")
}

// Join table for User <-> Role (Many-to-Many)
model UserRole {
  userId     String   @map("user_id")
  roleId     String   @map("role_id")
  assignedAt DateTime @default(now()) @map("assigned_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
  @@index([roleId]) // Index foreign keys
  @@map("user_roles")
}

// Join table for Role <-> Permission (Many-to-Many)
model RolePermission {
  roleId       String   @map("role_id")
  permissionId String   @map("permission_id")
  assignedAt   DateTime @default(now()) @map("assigned_at")

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@index([permissionId]) // Index foreign keys
  @@map("role_permissions")
}

// Products & Catalog
model Category {
  id               String   @id @default(uuid())
  tenantId         String   @map("tenant_id")
  parentCategoryId String?  @map("parent_category_id")
  name             String
  description      String?
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  tenant         Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  parentCategory Category?         @relation("CategoryHierarchy", fields: [parentCategoryId], references: [id], onDelete: SetNull) // Avoid self-cascade issues
  subCategories  Category[]        @relation("CategoryHierarchy")
  products       ProductCategory[] // Many-to-many relation via ProductCategory table

  @@index([tenantId])
  @@index([parentCategoryId])
  @@map("categories")
}

model Product {
  id                   String      @id @default(uuid())
  tenantId             String      @map("tenant_id")
  sku                  String
  upc                  String?
  ean                  String?
  name                 String
  description          String?
  productType          ProductType @default(STANDARD) @map("product_type")
  unitOfMeasure        String?     @default("each") @map("unit_of_measure")
  brand                String?
  isActive             Boolean     @default(true) @map("is_active")
  isStockTracked       Boolean     @default(true) @map("is_stock_tracked")
  requiresSerialNumber Boolean     @default(false) @map("requires_serial_number")
  requiresLotTracking  Boolean     @default(false) @map("requires_lot_tracking")
  requiresExpiryDate   Boolean     @default(false) @map("requires_expiry_date")
  basePrice            Decimal?    @map("base_price") @db.Decimal(19, 4)
  costPrice            Decimal?    @map("cost_price") @db.Decimal(19, 4) // Standard or Average Cost
  taxable              Boolean     @default(true)
  weight               Decimal?    @db.Decimal(10, 4)
  weightUnit           String?     @map("weight_unit") // kg, lb
  dimensions           Json? // { length: x, width: y, height: z, unit: 'cm'/'in' }
  customAttributes     Json?       @default("{}") @map("custom_attributes")
  createdAt            DateTime    @default(now()) @map("created_at")
  updatedAt            DateTime    @updatedAt @map("updated_at")

  tenant          Tenant                    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  categories      ProductCategory[] // Many-to-many relation
  variants        ProductVariant[] // One-to-many relation for variants
  kitComponents   ProductComponent[]        @relation("ParentProduct") // Product as a Kit/Bundle
  componentOfKits ProductComponent[]        @relation("ChildProduct") // Product as a component
  inventoryItems  InventoryItem[]
  inventoryTx     InventoryTransaction[]
  poItems         PurchaseOrderItem[]
  orderItems      OrderItem[]
  returnItems     ReturnItem[]
  adjustmentItems InventoryAdjustmentItem[]
  transferItems   InventoryTransferItem[]

  @@unique([tenantId, sku])
  @@index([tenantId])
  @@index([name])
  @@map("products")
}

// Join table for Product <-> Category (Many-to-Many)
model ProductCategory {
  productId  String   @map("product_id")
  categoryId String   @map("category_id")
  assignedAt DateTime @default(now()) @map("assigned_at")

  product  Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@id([productId, categoryId])
  @@index([categoryId])
  @@map("product_categories")
}

// Optional: For products with variations like size/color
model ProductVariant {
  id               String   @id @default(uuid())
  tenantId         String   @map("tenant_id") // Needed for direct queries potentially
  productId        String   @map("product_id")
  sku              String
  upc              String?
  ean              String?
  name             String? // e.g., "T-Shirt - Red, Large" (can be auto-generated)
  attributes       Json // { "color": "Red", "size": "Large" } - Indexed for searching variations
  priceModifier    Decimal  @default(0) @map("price_modifier") @db.Decimal(19, 4) // Add/subtract from base product price
  costModifier     Decimal  @default(0) @map("cost_modifier") @db.Decimal(19, 4)
  weightModifier   Decimal  @default(0) @map("weight_modifier") @db.Decimal(10, 4)
  customAttributes Json?    @default("{}") @map("custom_attributes")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  // If variants need separate inventory tracking, link InventoryItem here instead of Product
  // @@index([attributes], type: Gin) // Commented out: Check if your DB supports GIN index on JSONB

  @@unique([productId, sku]) // Variant SKU unique per base product
  @@index([tenantId]) // Facilitate tenant-wide variant search if needed
  @@map("product_variants")
}

// For Kits/Bundles
model ProductComponent {
  id              String   @id @default(uuid())
  tenantId        String   @map("tenant_id") // Needed for direct queries
  parentProductId String   @map("parent_product_id") // The Kit/Bundle product
  childProductId  String   @map("child_product_id") // The component product
  quantity        Decimal  @db.Decimal(10, 4) // Quantity of child needed for 1 parent
  createdAt       DateTime @default(now()) @map("created_at")

  parentProduct Product @relation("ParentProduct", fields: [parentProductId], references: [id], onDelete: Cascade)
  childProduct  Product @relation("ChildProduct", fields: [childProductId], references: [id], onDelete: Restrict) // Prevent deleting component if used in kit

  @@unique([parentProductId, childProductId])
  @@index([tenantId])
  @@index([childProductId])
  @@map("product_components")
}

// Inventory
model Location {
  id               String       @id @default(uuid())
  tenantId         String       @map("tenant_id")
  parentLocationId String?      @map("parent_location_id")
  name             String
  address          Json? // { street, city, state, postal_code, country }
  locationType     LocationType @default(WAREHOUSE) @map("location_type")
  isActive         Boolean      @default(true) @map("is_active")
  createdAt        DateTime     @default(now()) @map("created_at")
  updatedAt        DateTime     @updatedAt @map("updated_at")

  tenant               Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  parentLocation       Location?              @relation("LocationHierarchy", fields: [parentLocationId], references: [id], onDelete: SetNull)
  subLocations         Location[]             @relation("LocationHierarchy")
  inventoryItems       InventoryItem[]
  inventoryTx          InventoryTransaction[]
  sourceTransfers      InventoryTransfer[]    @relation("SourceLocation")
  destTransfers        InventoryTransfer[]    @relation("DestinationLocation")
  inventoryAdjustments InventoryAdjustment[]
  purchaseOrders       PurchaseOrder[] // Delivery location for POs
  orders               Order[] // Sale/fulfillment location for Orders
  posSessions          PosSession[]
  returnRestockItems   ReturnItem[] // Location where returned items are restocked

  @@unique([tenantId, name])
  @@index([tenantId])
  @@index([parentLocationId])
  @@map("locations")
}

// Summarizes stock levels per product per location
model InventoryItem {
  id                String    @id @default(uuid())
  tenantId          String    @map("tenant_id")
  productId         String    @map("product_id")
  locationId        String    @map("location_id")
  quantityOnHand    Decimal   @default(0) @map("quantity_on_hand") @db.Decimal(19, 4)
  quantityAllocated Decimal   @default(0) @map("quantity_allocated") @db.Decimal(19, 4) // Committed to sales orders
  quantityIncoming  Decimal   @default(0) @map("quantity_incoming") @db.Decimal(19, 4) // On purchase orders / transfers in-transit
  reorderPoint      Decimal?  @map("reorder_point") @db.Decimal(19, 4)
  reorderQuantity   Decimal?  @map("reorder_quantity") @db.Decimal(19, 4)
  abcCategory       String?   @map("abc_category") @db.Char(1) // A, B, C
  lastCountedAt     DateTime? @map("last_counted_at")
  averageCost       Decimal?  @map("average_cost") @db.Decimal(19, 4) // For Moving Average valuation
  customAttributes  Json?     @default("{}") @map("custom_attributes")
  updatedAt         DateTime  @updatedAt @map("updated_at") // Tracks last inventory update time

  tenant   Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  product  Product           @relation(fields: [productId], references: [id], onDelete: Cascade)
  location Location          @relation(fields: [locationId], references: [id], onDelete: Cascade)
  details  InventoryDetail[] // One-to-many relation for lot/serial details

  @@unique([tenantId, productId, locationId])
  @@index([tenantId])
  @@index([locationId])
  @@index([updatedAt]) // Useful for finding recently updated items
  @@map("inventory_items")
}

// Tracks specific lots/serials for an InventoryItem
model InventoryDetail {
  id              String    @id @default(uuid())
  tenantId        String    @map("tenant_id") // Denormalized for potential direct queries
  inventoryItemId String    @map("inventory_item_id")
  lotNumber       String?   @map("lot_number")
  serialNumber    String?   @map("serial_number") // Should be unique across tenant if used
  expiryDate      DateTime? @map("expiry_date") @db.Date
  quantity        Decimal   @db.Decimal(19, 4) // Quantity for this specific lot/serial in this item record
  unitCost        Decimal?  @map("unit_cost") @db.Decimal(19, 4) // Cost for this specific lot (for FIFO/LIFO layers)
  receivedAt      DateTime  @default(now()) @map("received_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  inventoryItem InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  @@unique([tenantId, serialNumber], name: "unique_tenant_serial") // Ensure serial numbers are unique within a tenant if not null
  @@index([inventoryItemId])
  @@index([tenantId])
  @@index([lotNumber])
  @@index([expiryDate])
  @@map("inventory_details")
}

// The immutable log of all inventory movements
model InventoryTransaction {
  id                  BigInt                   @id @default(autoincrement()) @map("transaction_id")
  tenantId            String                   @map("tenant_id")
  timestamp           DateTime                 @default(now())
  productId           String                   @map("product_id")
  locationId          String                   @map("location_id")
  transactionType     InventoryTransactionType @map("transaction_type")
  quantityChange      Decimal                  @map("quantity_change") @db.Decimal(19, 4) // Positive for increase, negative for decrease
  unitCost            Decimal?                 @map("unit_cost") @db.Decimal(19, 4) // Cost at the time of transaction (Crucial for valuation)
  lotNumber           String?                  @map("lot_number")
  serialNumber        String?                  @map("serial_number")
  expiryDate          DateTime?                @map("expiry_date") @db.Date
  relatedOrderId      String?                  @map("related_order_id")
  relatedOrderItemId  String?                  @map("related_order_item_id")
  relatedPoId         String?                  @map("related_po_id")
  relatedPoItemId     String?                  @map("related_po_item_id")
  relatedTransferId   String?                  @map("related_transfer_id")
  relatedAdjustmentId String?                  @map("related_adjustment_id")
  relatedReturnItemId String?                  @map("related_return_item_id") // Link to return item for restocks
  userId              String?                  @map("user_id") // User performing the action
  notes               String?

  tenant              Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  product             Product              @relation(fields: [productId], references: [id], onDelete: Restrict) // Don't delete product if transactions exist
  location            Location             @relation(fields: [locationId], references: [id], onDelete: Restrict) // Don't delete location if tx exist
  order               Order?               @relation(fields: [relatedOrderId], references: [id], onDelete: SetNull)
  orderItem           OrderItem?           @relation(fields: [relatedOrderItemId], references: [id], onDelete: SetNull)
  purchaseOrder       PurchaseOrder?       @relation(fields: [relatedPoId], references: [id], onDelete: SetNull)
  purchaseOrderItem   PurchaseOrderItem?   @relation(fields: [relatedPoItemId], references: [id], onDelete: SetNull)
  inventoryTransfer   InventoryTransfer?   @relation(fields: [relatedTransferId], references: [id], onDelete: SetNull)
  inventoryAdjustment InventoryAdjustment? @relation(fields: [relatedAdjustmentId], references: [id], onDelete: SetNull)
  returnItem          ReturnItem?          @relation(fields: [relatedReturnItemId], references: [id], onDelete: SetNull)
  user                User?                @relation("PerformedByUser", fields: [userId], references: [id], onDelete: SetNull)

  @@index([tenantId, timestamp]) // Crucial for time-series analysis and partitioning
  @@index([tenantId, productId, locationId, timestamp]) // For product-location history
  @@index([relatedOrderId])
  @@index([relatedPoId])
  @@index([relatedTransferId])
  @@index([relatedAdjustmentId])
  @@index([userId])
  @@map("inventory_transactions")
}

model InventoryTransfer {
  id                    String         @id @default(uuid())
  tenantId              String         @map("tenant_id")
  sourceLocationId      String         @map("source_location_id")
  destinationLocationId String         @map("destination_location_id")
  status                TransferStatus
  transferDate          DateTime       @default(now()) @map("transfer_date") @db.Date
  estimatedDeliveryDate DateTime?      @map("estimated_delivery_date") @db.Date
  trackingNumber        String?        @map("tracking_number")
  notes                 String?
  createdByUserId       String?        @map("created_by_user_id")
  createdAt             DateTime       @default(now()) @map("created_at")
  updatedAt             DateTime       @updatedAt @map("updated_at")

  tenant                Tenant                  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sourceLocation        Location                @relation("SourceLocation", fields: [sourceLocationId], references: [id], onDelete: Restrict)
  destinationLocation   Location                @relation("DestinationLocation", fields: [destinationLocationId], references: [id], onDelete: Restrict)
  createdByUser         User?                   @relation("CreatedByUser", fields: [createdByUserId], references: [id], onDelete: SetNull)
  items                 InventoryTransferItem[]
  inventoryTransactions InventoryTransaction[] // Can link transactions related to this transfer

  @@index([tenantId])
  @@index([status])
  @@index([sourceLocationId])
  @@index([destinationLocationId])
  @@map("inventory_transfers")
}

model InventoryTransferItem {
  id                String  @id @default(uuid())
  tenantId          String  @map("tenant_id") // Keep tenantId for potential scoping/filtering
  transferId        String  @map("transfer_id")
  productId         String  @map("product_id")
  quantityRequested Decimal @map("quantity_requested") @db.Decimal(19, 4)
  quantityShipped   Decimal @default(0) @map("quantity_shipped") @db.Decimal(19, 4)
  quantityReceived  Decimal @default(0) @map("quantity_received") @db.Decimal(19, 4)
  lotNumber         String? @map("lot_number") // Specific lot being transferred
  serialNumber      String? @map("serial_number") // Specific serial being transferred

  // tenant              Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade) // <<< Removed this potentially redundant relation
  transfer InventoryTransfer @relation(fields: [transferId], references: [id], onDelete: Cascade)
  product  Product           @relation(fields: [productId], references: [id], onDelete: Restrict) // Don't delete product if in transfer

  @@index([transferId])
  @@index([productId])
  @@index([tenantId]) // Index tenantId if you query these directly by tenant
  @@map("inventory_transfer_items")
}

model InventoryAdjustment {
  id              String   @id @default(uuid())
  tenantId        String   @map("tenant_id")
  locationId      String   @map("location_id")
  adjustmentDate  DateTime @default(now()) @map("adjustment_date") @db.Date
  reasonCode      String?  @map("reason_code") // e.g., 'damage', 'theft', 'stock_count_correction'
  notes           String?
  createdByUserId String?  @map("created_by_user_id")
  createdAt       DateTime @default(now()) @map("created_at")

  tenant                Tenant                    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  location              Location                  @relation(fields: [locationId], references: [id], onDelete: Restrict)
  createdByUser         User?                     @relation("CreatedByUser", fields: [createdByUserId], references: [id], onDelete: SetNull)
  items                 InventoryAdjustmentItem[]
  inventoryTransactions InventoryTransaction[] // Link transactions related to this adjustment

  @@index([tenantId])
  @@index([locationId])
  @@index([adjustmentDate])
  @@map("inventory_adjustments")
}

model InventoryAdjustmentItem {
  id             String   @id @default(uuid())
  tenantId       String   @map("tenant_id") // Keep tenantId for potential scoping/filtering
  adjustmentId   String   @map("adjustment_id")
  productId      String   @map("product_id")
  quantityChange Decimal  @map("quantity_change") @db.Decimal(19, 4) // Positive or negative
  unitCost       Decimal? @map("unit_cost") @db.Decimal(19, 4) // For valuation impact
  lotNumber      String?  @map("lot_number")
  serialNumber   String?  @map("serial_number")

  // tenant            Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade) // <<< Removed this potentially redundant relation
  adjustment InventoryAdjustment @relation(fields: [adjustmentId], references: [id], onDelete: Cascade)
  product    Product             @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@index([adjustmentId])
  @@index([productId])
  @@index([tenantId]) // Index tenantId if you query these directly by tenant
  @@map("inventory_adjustment_items")
}

// Suppliers & Purchasing
model Supplier {
  id               String   @id @default(uuid())
  tenantId         String   @map("tenant_id")
  name             String
  contactName      String?  @map("contact_name")
  email            String?
  phone            String?
  address          Json?
  paymentTerms     String?  @map("payment_terms")
  isActive         Boolean  @default(true) @map("is_active")
  customAttributes Json?    @default("{}") @map("custom_attributes")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  tenant         Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  purchaseOrders PurchaseOrder[]

  @@unique([tenantId, name]) // Assume supplier names are unique per tenant
  @@index([tenantId])
  @@map("suppliers")
}

model PurchaseOrder {
  id                   String              @id @default(uuid())
  tenantId             String              @map("tenant_id")
  poNumber             String              @map("po_number") // Auto-generated or manual
  supplierId           String              @map("supplier_id")
  locationId           String              @map("location_id") // Delivery location
  status               PurchaseOrderStatus
  orderDate            DateTime            @default(now()) @map("order_date") @db.Date
  expectedDeliveryDate DateTime?           @map("expected_delivery_date") @db.Date
  notes                String?
  shippingCost         Decimal             @default(0) @map("shipping_cost") @db.Decimal(19, 4)
  taxAmount            Decimal             @default(0) @map("tax_amount") @db.Decimal(19, 4)
  totalAmount          Decimal             @default(0) @map("total_amount") @db.Decimal(19, 4) // Calculated
  createdByUserId      String?             @map("created_by_user_id")
  createdAt            DateTime            @default(now()) @map("created_at")
  updatedAt            DateTime            @updatedAt @map("updated_at")

  tenant                Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  supplier              Supplier               @relation(fields: [supplierId], references: [id], onDelete: Restrict)
  location              Location               @relation(fields: [locationId], references: [id], onDelete: Restrict)
  createdByUser         User?                  @relation("CreatedByUser", fields: [createdByUserId], references: [id], onDelete: SetNull)
  items                 PurchaseOrderItem[]
  inventoryTransactions InventoryTransaction[] // Link receiving transactions

  @@unique([tenantId, poNumber])
  @@index([tenantId])
  @@index([supplierId])
  @@index([locationId])
  @@index([status])
  @@index([orderDate])
  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id               String    @id @default(uuid())
  tenantId         String    @map("tenant_id") // Keep tenantId for potential scoping/filtering
  poId             String    @map("po_id")
  productId        String    @map("product_id")
  description      String? // Can override product name
  quantityOrdered  Decimal   @map("quantity_ordered") @db.Decimal(19, 4)
  quantityReceived Decimal   @default(0) @map("quantity_received") @db.Decimal(19, 4)
  unitCost         Decimal   @map("unit_cost") @db.Decimal(19, 4)
  taxRate          Decimal   @default(0) @map("tax_rate") @db.Decimal(5, 4)
  lineTotal        Decimal   @map("line_total") @db.Decimal(19, 4) // Calculated
  receivedAt       DateTime? @map("received_at") // Last received date for this item
  notes            String?

  // tenant                Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade) // <<< Removed this potentially redundant relation
  purchaseOrder         PurchaseOrder          @relation(fields: [poId], references: [id], onDelete: Cascade)
  product               Product                @relation(fields: [productId], references: [id], onDelete: Restrict)
  inventoryTransactions InventoryTransaction[] // Link receiving transactions for this item

  @@index([poId])
  @@index([productId])
  @@index([tenantId]) // Index tenantId if you query these directly by tenant
  @@map("purchase_order_items")
}

// Customers
model CustomerGroup {
  id          String   @id @default(uuid())
  tenantId    String   @map("tenant_id")
  name        String
  description String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  tenant    Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customers Customer[]

  @@unique([tenantId, name])
  @@index([tenantId])
  @@map("customer_groups")
}

model Customer {
  id                     String   @id @default(uuid())
  tenantId               String   @map("tenant_id")
  firstName              String?  @map("first_name")
  lastName               String?  @map("last_name")
  email                  String?
  phone                  String?
  companyName            String?  @map("company_name")
  loyaltyPoints          Int      @default(0) @map("loyalty_points")
  customerGroupId        String?  @map("customer_group_id")
  defaultBillingAddress  Json?    @map("default_billing_address")
  defaultShippingAddress Json?    @map("default_shipping_address")
  taxExempt              Boolean  @default(false) @map("tax_exempt")
  notes                  String?
  customAttributes       Json?    @default("{}") @map("custom_attributes")
  createdAt              DateTime @default(now()) @map("created_at")
  updatedAt              DateTime @updatedAt @map("updated_at")

  tenant        Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customerGroup CustomerGroup? @relation(fields: [customerGroupId], references: [id], onDelete: SetNull)
  orders        Order[]
  // addresses            CustomerAddress[] // Could have a separate address table if needed

  @@unique([tenantId, email], name: "unique_tenant_email") // Assuming email is main identifier per tenant (if not null)
  @@index([tenantId])
  @@index([email])
  @@index([customerGroupId])
  @@map("customers")
}

// Orders & POS
model Order {
  id               String      @id @default(uuid())
  tenantId         String      @map("tenant_id")
  orderNumber      String      @map("order_number") // Auto-generated
  customerId       String?     @map("customer_id") // Nullable for guest checkout
  locationId       String      @map("location_id") // Sale location
  posTerminalId    String?     @map("pos_terminal_id") // Identifier for the POS device
  userId           String?     @map("user_id") // Salesperson
  orderType        OrderType   @default(POS) @map("order_type")
  status           OrderStatus
  orderDate        DateTime    @default(now()) @map("order_date")
  subtotal         Decimal     @db.Decimal(19, 4)
  discountAmount   Decimal     @default(0) @map("discount_amount") @db.Decimal(19, 4)
  taxAmount        Decimal     @default(0) @map("tax_amount") @db.Decimal(19, 4)
  shippingCost     Decimal     @default(0) @map("shipping_cost") @db.Decimal(19, 4)
  totalAmount      Decimal     @map("total_amount") @db.Decimal(19, 4)
  currencyCode     String      @map("currency_code") @db.Char(3) // ISO 4217
  notes            String?
  shippingAddress  Json?       @map("shipping_address")
  shippingMethod   String?     @map("shipping_method")
  trackingNumber   String?     @map("tracking_number")
  customAttributes Json?       @default("{}") @map("custom_attributes")
  isBackordered    Boolean     @default(false) @map("is_backordered")
  createdAt        DateTime    @default(now()) @map("created_at")
  updatedAt        DateTime    @updatedAt @map("updated_at")

  tenant                 Tenant                  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer               Customer?               @relation(fields: [customerId], references: [id], onDelete: SetNull)
  location               Location                @relation(fields: [locationId], references: [id], onDelete: Restrict)
  user                   User?                   @relation("CreatedByUser", fields: [userId], references: [id], onDelete: SetNull)
  items                  OrderItem[]
  payments               Payment[]
  inventoryTransactions  InventoryTransaction[] // Link stock deduction transactions
  returns                Return[]                @relation("OriginalOrderReturns") // Returns associated with this order
  returnForExchange      Return?                 @relation("ExchangeOrderReturn") // If this order is an exchange for a return (changed to one-to-one? check logic)
  posSessionTransactions PosSessionTransaction[] // <<< Added this inverse relation

  @@unique([tenantId, orderNumber])
  @@index([tenantId])
  @@index([customerId])
  @@index([locationId])
  @@index([userId])
  @@index([status])
  @@index([orderDate])
  @@map("orders")
}

model OrderItem {
  id                String   @id @default(uuid())
  tenantId          String   @map("tenant_id") // Keep tenantId for potential scoping/filtering
  orderId           String   @map("order_id")
  productId         String   @map("product_id")
  productSnapshot   Json?    @map("product_snapshot") // Store product details at time of sale (name, sku, price)
  quantity          Decimal  @db.Decimal(19, 4)
  unitPrice         Decimal  @map("unit_price") @db.Decimal(19, 4) // Price per unit *after* item-specific discounts
  originalUnitPrice Decimal? @map("original_unit_price") @db.Decimal(19, 4) // Price before discounts
  discountAmount    Decimal  @default(0) @map("discount_amount") @db.Decimal(19, 4)
  taxAmount         Decimal  @default(0) @map("tax_amount") @db.Decimal(19, 4)
  taxRate           Decimal  @default(0) @map("tax_rate") @db.Decimal(5, 4)
  lineTotal         Decimal  @map("line_total") @db.Decimal(19, 4) // Calculated: (unitPrice * quantity)
  lotNumber         String?  @map("lot_number") // Specific lot sold
  serialNumber      String?  @map("serial_number") // Specific serial sold
  quantityReturned  Decimal  @default(0) @map("quantity_returned") @db.Decimal(19, 4)
  notes             String?
  customAttributes  Json?    @default("{}") @map("custom_attributes")

  // tenant              Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade) // <<< Removed this potentially redundant relation
  order                 Order                  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product               Product                @relation(fields: [productId], references: [id], onDelete: Restrict) // Don't delete product if in orders
  inventoryTransactions InventoryTransaction[] // Link stock deduction transaction for this item
  returnItems           ReturnItem[] // Link return items back to the original order item

  @@index([orderId])
  @@index([productId])
  @@index([tenantId]) // Index tenantId if you query these directly by tenant
  @@map("order_items")
}

model Payment {
  id                   String        @id @default(uuid())
  tenantId             String        @map("tenant_id") // Keep tenantId for potential scoping/filtering
  orderId              String        @map("order_id")
  paymentMethod        PaymentMethod @map("payment_method")
  amount               Decimal       @db.Decimal(19, 4)
  currencyCode         String        @map("currency_code") @db.Char(3) // ISO 4217
  status               PaymentStatus
  transactionReference String?       @map("transaction_reference") // From payment processor
  paymentDetails       Json?         @map("payment_details") // e.g., last 4 digits of card, auth code
  paymentDate          DateTime      @default(now()) @map("payment_date")
  processedByUserId    String?       @map("processed_by_user_id")
  notes                String?

  // tenant                Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade) // <<< Removed this potentially redundant relation
  order           Order @relation(fields: [orderId], references: [id], onDelete: Cascade) // Payments tied to order lifecycle
  processedByUser User? @relation("ProcessedByUser", fields: [processedByUserId], references: [id], onDelete: SetNull)

  @@index([orderId])
  @@index([status])
  @@index([paymentMethod])
  @@index([paymentDate])
  @@index([tenantId]) // Index tenantId if you query these directly by tenant
  @@map("payments")
}

// Or handle returns via negative qty orders/adjustments (this is explicit)
model Return {
  id                String       @id @default(uuid())
  tenantId          String       @map("tenant_id")
  originalOrderId   String       @map("original_order_id")
  returnOrderId     String?      @unique @map("return_order_id") // Optional link to a new order if exchange
  returnDate        DateTime     @default(now()) @map("return_date")
  reason            String?
  processedByUserId String?      @map("processed_by_user_id")
  totalRefundAmount Decimal?     @map("total_refund_amount") @db.Decimal(19, 4)
  status            ReturnStatus

  tenant          Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade) // <<< Keep this direct relation
  originalOrder   Order        @relation("OriginalOrderReturns", fields: [originalOrderId], references: [id], onDelete: Restrict) // Don't delete order if returns exist
  exchangeOrder   Order?       @relation("ExchangeOrderReturn", fields: [returnOrderId], references: [id], onDelete: SetNull) // Link to the new order created for the exchange
  processedByUser User?        @relation("CreatedByUser", fields: [processedByUserId], references: [id], onDelete: SetNull) // Changed relation name for consistency with User model
  items           ReturnItem[]

  @@index([tenantId])
  @@index([originalOrderId])
  @@index([returnOrderId])
  @@index([status])
  @@map("returns")
}

model ReturnItem {
  id                  String               @id @default(uuid())
  tenantId            String               @map("tenant_id") // Keep tenantId for potential scoping/filtering
  returnId            String               @map("return_id")
  originalOrderItemId String               @map("original_order_item_id")
  productId           String               @map("product_id")
  quantity            Decimal              @db.Decimal(19, 4)
  unitRefundAmount    Decimal?             @map("unit_refund_amount") @db.Decimal(19, 4)
  restockLocationId   String?              @map("restock_location_id") // Where item was restocked (if applicable)
  condition           ReturnItemCondition? // 'sellable', 'damaged', 'defective'
  lotNumber           String?              @map("lot_number") // Lot being returned
  serialNumber        String?              @map("serial_number") // Serial being returned

  // tenant                Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade) // <<< Removed this potentially redundant relation
  returnRequest         Return                 @relation(fields: [returnId], references: [id], onDelete: Cascade)
  originalOrderItem     OrderItem              @relation(fields: [originalOrderItemId], references: [id], onDelete: Restrict) // Keep link to original sale item
  product               Product                @relation(fields: [productId], references: [id], onDelete: Restrict)
  restockLocation       Location?              @relation(fields: [restockLocationId], references: [id], onDelete: SetNull)
  inventoryTransactions InventoryTransaction[] // Link restock/disposal inventory transactions

  @@index([returnId])
  @@index([originalOrderItemId])
  @@index([productId])
  @@index([tenantId]) // Index tenantId if you query these directly by tenant
  @@map("return_items")
}

// For cash drawer management
model PosSession {
  id             String           @id @default(uuid())
  tenantId       String           @map("tenant_id")
  locationId     String           @map("location_id")
  posTerminalId  String           @map("pos_terminal_id")
  userId         String           @map("user_id") // User who opened/closed the session
  startTime      DateTime         @default(now()) @map("start_time")
  endTime        DateTime?        @map("end_time")
  startingCash   Decimal          @map("starting_cash") @db.Decimal(19, 4)
  endingCash     Decimal?         @map("ending_cash") @db.Decimal(19, 4) // Actual counted cash
  calculatedCash Decimal?         @map("calculated_cash") @db.Decimal(19, 4) // Expected cash based on transactions
  difference     Decimal?         @db.Decimal(19, 4) // ending_cash - calculated_cash
  status         PosSessionStatus
  notes          String?

  tenant       Tenant                  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  location     Location                @relation(fields: [locationId], references: [id], onDelete: Restrict)
  user         User                    @relation("ManagedByUser", fields: [userId], references: [id], onDelete: Restrict)
  transactions PosSessionTransaction[] // Log cash movements within this session

  @@index([tenantId])
  @@index([locationId])
  @@index([userId])
  @@index([status])
  @@index([startTime])
  @@map("pos_sessions")
}

// Log cash movements within a POS session
model PosSessionTransaction {
  id              String             @id @default(uuid())
  tenantId        String             @map("tenant_id") // Keep tenantId for potential scoping/filtering
  posSessionId    String             @map("pos_session_id")
  timestamp       DateTime           @default(now())
  transactionType PosTransactionType @map("transaction_type")
  amount          Decimal            @db.Decimal(19, 4) // Positive for in, negative for out
  relatedOrderId  String?            @map("related_order_id") // Link cash sale/refund to order
  notes           String?

  // tenant              Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade) // <<< Removed this potentially redundant relation
  posSession PosSession @relation(fields: [posSessionId], references: [id], onDelete: Cascade)
  order      Order?     @relation(fields: [relatedOrderId], references: [id], onDelete: SetNull) // Link to order if relevant

  @@index([posSessionId])
  @@index([timestamp])
  @@index([tenantId]) // Index tenantId if you query these directly by tenant
  @@map("pos_session_transactions")
}

// Configuration & Customization
// General system/tenant configuration store
model Configuration {
  id          String   @id @default(uuid())
  tenantId    String?  @map("tenant_id") // Null for system-wide config
  configKey   String   @map("config_key")
  configValue Json     @map("config_value")
  description String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  tenant Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, configKey]) // Config key unique per tenant (or globally if tenantId is NULL)
  @@index([tenantId]) // Index allows filtering by tenant or global (NULL)
  @@index([configKey])
  @@map("configurations")
}

model NotificationTemplate {
  id           String           @id @default(uuid())
  tenantId     String           @map("tenant_id")
  templateName String           @map("template_name")
  templateType NotificationType @map("template_type") // 'email', 'sms', 'system'
  eventTrigger String           @map("event_trigger") // e.g., 'order_confirmed', 'low_stock_alert'
  subject      String? // For email
  body         String // Supports template variables (e.g., Handlebars)
  isActive     Boolean          @default(true) @map("is_active")
  createdAt    DateTime         @default(now()) @map("created_at")
  updatedAt    DateTime         @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, templateName])
  @@index([tenantId])
  @@index([eventTrigger])
  @@map("notification_templates")
}

// Audit Logging
model AuditLog {
  id         BigInt   @id @default(autoincrement()) @map("log_id")
  tenantId   String?  @map("tenant_id") // Can be NULL for system events
  timestamp  DateTime @default(now())
  userId     String?  @map("user_id") // Can be NULL for system actions
  action     String // e.g., 'create_product', 'update_order_status', 'login'
  entityType String?  @map("entity_type") // e.g., 'product', 'order'
  entityId   String?  @map("entity_id") // Can be UUID or other identifiers
  details    Json? // Store old/new values or specific event details
  ipAddress  String?  @map("ip_address")
  userAgent  String?  @map("user_agent")

  tenant Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User?   @relation("ActionByUser", fields: [userId], references: [id], onDelete: SetNull)

  @@index([tenantId, timestamp]) // For filtering and partitioning
  @@index([userId])
  @@index([entityType, entityId])
  @@map("audit_logs")
}
