// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// ======================================================================
// == Configuration ==
// ======================================================================
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // Using PostgreSQL
  url      = env("DATABASE_URL")
  // Optional: Add relationMode = "prisma" if not using foreign keys at DB level,
  // but foreign keys are generally recommended for relational integrity.
  // relationMode = "prisma"
}

// ======================================================================
// == Enums ==
// ======================================================================

enum TenantStatus {
  ACTIVE    // Standard operational status
  SUSPENDED // Temporarily disabled, logins blocked
  TRIAL     // Trial period status
  DEACTIVATED // Soft deleted, logins blocked, prepared for archival/deletion
}

enum ProductType {
  STANDARD // A regular physical item tracked in inventory
  KIT      // A bundle sold as one unit, composed of other STANDARD products (stock deducted from components)
  BUNDLE   // Similar to KIT, often used interchangeably or for non-stock groupings
  SERVICE  // A non-physical item/service, not tracked in inventory
}

enum LocationType {
  WAREHOUSE // Distribution center, typically not customer-facing
  STORE     // Retail store, customer-facing
  VIRTUAL   // Represents stock held elsewhere (e.g., dropshipper, consignment) or non-physical locations
}

// Describes the reason for an inventory change
enum InventoryTransactionType {
  PURCHASE_RECEIPT     // Receiving stock from a Purchase Order
  SALE                 // Selling stock via an Order/POS
  ADJUSTMENT_IN        // Manual positive stock adjustment (e.g., found stock, data correction)
  ADJUSTMENT_OUT       // Manual negative stock adjustment (e.g., damage, theft, correction)
  TRANSFER_OUT         // Stock leaving a location for transfer
  TRANSFER_IN          // Stock arriving at a location from transfer
  CYCLE_COUNT_ADJUSTMENT // Adjustment resulting from a stock count variance (replaces plain ADJUSTMENT_* for counts)
  RETURN_RESTOCK       // Restocking a sellable returned item
  RETURN_DISPOSE       // Disposing of a non-sellable returned item (stock adjustment out)
  KIT_ASSEMBLY_CONSUME // Consuming component stock when building a KIT
  KIT_ASSEMBLY_PRODUCE // Producing (adding stock of) a KIT product
  // Consider adding STOCK_COUNT_SNAPSHOT for recording counted qty before adjustment?
}

enum TransferStatus {
  PENDING      // Request created, not yet shipped
  IN_TRANSIT   // Items have left the source location
  PARTIAL      // Partially received at destination (Optional, can just use IN_TRANSIT until fully received)
  COMPLETED    // All items received at destination
  CANCELLED    // Transfer cancelled before completion
}

enum PurchaseOrderStatus {
  DRAFT             // PO created but not finalized/submitted
  PENDING_APPROVAL  // PO submitted, awaiting manager/admin approval (optional step)
  APPROVED          // PO approved, ready to be sent
  SENT              // PO sent to the supplier
  PARTIALLY_RECEIVED// Some, but not all, items have been received
  FULLY_RECEIVED    // All items have been received
  CANCELLED         // PO cancelled
}

enum OrderType {
  POS    // Point of Sale transaction
  WEB    // Order from an e-commerce website
  PHONE  // Order taken over the phone
  MANUAL // Order created manually by staff
}

enum OrderStatus {
  PENDING_PAYMENT    // Awaiting payment confirmation (e.g., online checkout)
  PROCESSING         // Payment confirmed, order being prepared/fulfilled (inventory allocated/picked)
  SHIPPED            // Order has been shipped (for non-POS orders)
  COMPLETED          // Order fulfilled (picked up, delivered, or POS transaction finished)
  CANCELLED          // Order was cancelled before completion
  RETURNED           // All items in the order have been returned
  PARTIALLY_RETURNED // Some items in the order have been returned
}

enum PaymentMethod {
  CASH
  CREDIT_CARD
  DEBIT_CARD
  GIFT_CARD
  STORE_CREDIT
  BANK_TRANSFER
  CHECK // Cheque
  OTHER
}

enum PaymentStatus {
  PENDING   // Payment initiated but not confirmed
  COMPLETED // Payment successful
  FAILED    // Payment attempt failed
  REFUNDED  // Payment fully refunded
  PARTIALLY_REFUNDED // Payment partially refunded
}

enum ReturnStatus {
  PENDING   // Return request initiated
  APPROVED  // Return request approved, awaiting item receipt/processing
  REJECTED  // Return request denied
  COMPLETED // Return processed (refund/exchange issued, items handled)
}

enum ReturnItemCondition {
  SELLABLE // Item can be returned to stock
  DAMAGED  // Item is damaged but might have salvage value or specific disposal
  DEFECTIVE// Item is defective
  DISPOSED // Item was disposed of upon return
}

enum PosSessionStatus {
  OPEN       // Session active, transactions can occur
  CLOSED     // Shift ended, cash counted, awaiting reconciliation
  RECONCILED // Counts verified, session finalized
}

enum PosTransactionType {
  CASH_SALE   // Cash received from sale payment
  CASH_REFUND // Cash given out for refund payment
  PAY_IN      // Adding cash to drawer (float, deposit correction)
  PAY_OUT     // Removing cash from drawer (expenses, bank deposit prep)
}

enum NotificationType {
  EMAIL
  SMS
  SYSTEM // In-app notification/feed
}

// --- NEW Enums for Stock Count ---
enum StockCountStatus {
  PENDING     // Count initiated, items snapshotted, ready for counting
  COUNTING    // Physical counting in progress (items being entered)
  REVIEW      // All items entered, awaiting manager review/approval
  COMPLETED   // Count reviewed, adjustments posted, process finished
  CANCELLED   // Count process cancelled before completion
}

enum StockCountType {
  FULL        // Full physical inventory for the location
  CYCLE       // Partial count based on specific criteria
}

enum StockCountItemStatus {
  PENDING            // Not yet counted
  COUNTED            // Physical count entered
  RECOUNT_REQUESTED  // Manager requested a recount for this item
  APPROVED           // Variance (if any) approved for adjustment posting
  SKIPPED            // Reviewer decided to skip adjusting this item's variance
}

// ======================================================================
// == Models ==
// ======================================================================

// --- Core & Tenancy ---
model Tenant {
  id            String        @id @default(uuid())
  name          String        @unique // Added unique constraint
  status        TenantStatus  @default(ACTIVE)
  configuration Json?         @default("{}")
  createdAt     DateTime      @default(now()) @map("created_at")
  updatedAt     DateTime      @updatedAt @map("updated_at")
  deactivatedAt DateTime?     @map("deactivated_at")

  // Relations
  users                 User[]
  customFields          CustomFieldDefinition[]
  roles                 Role[]
  products              Product[]
  categories            Category[]
  locations             Location[]
  inventoryItems        InventoryItem[]
  inventoryTx           InventoryTransaction[]
  inventoryTransfers    InventoryTransfer[]
  inventoryAdjustments  InventoryAdjustment[]
  suppliers             Supplier[]
  purchaseOrders        PurchaseOrder[]
  customers             Customer[]
  customerGroups        CustomerGroup[]
  orders                Order[]
  posSessions           PosSession[]
  configurations        Configuration[]
  notificationTemplates NotificationTemplate[]
  auditLogs             AuditLog[]
  returns               Return[]
  stockCounts           StockCount[] 

  @@index([status])
  @@map("tenants")
}

model CustomFieldDefinition {
  id          String    @id @default(uuid())
  tenantId    String    @map("tenant_id")
  entityType  String    @map("entity_type") // e.g., 'product', 'customer'
  fieldKey    String    @map("field_key")   // e.g., 'material', 'warranty_days'
  label       String    // e.g., 'Material Type', 'Warranty (Days)'
  fieldType   String    @map("field_type")  // TEXT, NUMBER, DATE, BOOLEAN, SELECT
  options     Json?     // For SELECT type: [{ "value": "cotton", "label": "Cotton" }, ...]
  isRequired  Boolean   @default(false) @map("is_required")
  createdAt   DateTime  @default(now()) @map("created_at")

  tenant      Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  // Cannot link values directly here due to varying entity types

  @@unique([tenantId, entityType, fieldKey]) // Unique field key per entity type per tenant
  @@index([tenantId, entityType])
  @@map("custom_field_definitions")
}

// --- User & Security Models ---
model RefreshToken {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  tokenHash String   @unique @map("token_hash")
  userAgent String?  @map("user_agent")
  ipAddress String?  @map("ip_address")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  revokedAt DateTime? @map("revoked_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  tokenHash String   @unique @map("token_hash")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  usedAt    DateTime? @map("used_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}

model User {
  id            String    @id @default(uuid())
  tenantId      String?   @map("tenant_id") // Nullable for Super Admins or unassigned users
  email         String    @unique // Email must be globally unique
  passwordHash  String    @map("password_hash")
  firstName     String?   @map("first_name")
  lastName      String?   @map("last_name")
  phoneNumber   String?   @map("phone_number")
  isActive      Boolean   @default(true) @map("is_active")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  tenant                Tenant?                @relation(fields: [tenantId], references: [id], onDelete: SetNull) // User not deleted if Tenant is
  roles                 UserRole[]             // Assigned roles
  createdPOs            PurchaseOrder[]        @relation("CreatedByUser")
  createdOrders         Order[]                @relation("CreatedByUser")
  processedPayments     Payment[]              @relation("ProcessedByUser")
  createdReturns        Return[]               @relation("CreatedByUser")
  posSessions           PosSession[]           @relation("ManagedByUser")
  auditLogs             AuditLog[]             @relation("ActionByUser")
  inventoryTransactions InventoryTransaction[] @relation("PerformedByUser")
  inventoryAdjustments  InventoryAdjustment[]  @relation("CreatedByUser")
  inventoryTransfers    InventoryTransfer[]    @relation("CreatedByUser")
  refreshTokens         RefreshToken[]         // User's refresh tokens
  passwordResetTokens   PasswordResetToken[]   // User's password reset tokens
  initiatedStockCounts   StockCount[]          @relation("InitiatedStockCounts")
  reviewedStockCounts    StockCount[]          @relation("ReviewedStockCounts")
  completedStockCounts   StockCount[]          @relation("CompletedStockCounts")
  countedStockCountItems StockCountItem[]      @relation("CountedStockCountItems")

  @@index([tenantId]) // Index nullable FK
  @@index([email])
  @@map("users")
}

model Role {
  id            String   @id @default(uuid())
  tenantId      String   @map("tenant_id")
  name          String
  description   String?
  isSystemRole  Boolean  @default(false) @map("is_system_role")
  createdAt     DateTime @default(now()) @map("created_at")

  tenant        Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade) // Roles deleted if tenant deleted
  users         UserRole[]       // Users assigned this role
  permissions   RolePermission[] // Permissions granted by this role

  @@unique([tenantId, name]) // Role name unique per tenant
  @@index([tenantId])
  @@map("roles")
}

model Permission {
  id            String           @id @default(uuid())
  permissionKey String           @unique @map("permission_key") // e.g., 'product:create'
  description   String?
  roles         RolePermission[] // Roles that include this permission

  @@map("permissions")
}

// Join table for User <-> Role (Many-to-Many)
model UserRole {
  userId     String   @map("user_id")
  roleId     String   @map("role_id")
  assignedAt DateTime @default(now()) @map("assigned_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade) // Delete assignment if user deleted
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade) // Delete assignment if role deleted

  @@id([userId, roleId]) // Composite primary key
  @@index([roleId])
  @@map("user_roles")
}

// Join table for Role <-> Permission (Many-to-Many)
model RolePermission {
  roleId       String   @map("role_id")
  permissionId String   @map("permission_id")
  assignedAt   DateTime @default(now()) @map("assigned_at")

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade) // Delete assignment if role deleted
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade) // Delete assignment if permission deleted (less likely)

  @@id([roleId, permissionId]) // Composite primary key
  @@index([permissionId])
  @@map("role_permissions")
}

// --- Product & Catalog Models ---
model Category {
  id               String   @id @default(uuid())
  tenantId         String   @map("tenant_id")
  parentCategoryId String?  @map("parent_category_id")
  name             String
  description      String?
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  tenant         Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  parentCategory Category?         @relation("CategoryHierarchy", fields: [parentCategoryId], references: [id], onDelete: SetNull) // Allow re-parenting/making top-level if parent deleted
  subCategories  Category[]        @relation("CategoryHierarchy")
  products       ProductCategory[]

  @@unique([tenantId, name, parentCategoryId]) // Name unique under a specific parent (or null for top-level) per tenant
  @@index([tenantId])
  @@index([parentCategoryId])
  @@map("categories")
}

model Product {
  id                   String      @id @default(uuid())
  tenantId             String      @map("tenant_id")
  sku                  String      // Stock Keeping Unit
  upc                  String?     // Universal Product Code
  ean                  String?     // European Article Number
  name                 String
  description          String?
  productType          ProductType @default(STANDARD) @map("product_type")
  unitOfMeasure        String?     @default("each") @map("unit_of_measure")
  brand                String?
  isActive             Boolean     @default(true) @map("is_active")
  isStockTracked       Boolean     @default(true) @map("is_stock_tracked")
  requiresSerialNumber Boolean     @default(false) @map("requires_serial_number")
  requiresLotTracking  Boolean     @default(false) @map("requires_lot_tracking")
  requiresExpiryDate   Boolean     @default(false) @map("requires_expiry_date")
  basePrice            Decimal?    @map("base_price") @db.Decimal(19, 4)
  costPrice            Decimal?    @map("cost_price") @db.Decimal(19, 4)
  taxable              Boolean     @default(true)
  weight               Decimal?    @db.Decimal(10, 4)
  weightUnit           String?     @map("weight_unit") // e.g., kg, lb
  dimensions           Json?       // e.g., { "length": 10, "width": 5, "height": 2, "unit": "cm" }
  customAttributes     Json?       @default("{}") @map("custom_attributes")
  createdAt            DateTime    @default(now()) @map("created_at")
  updatedAt            DateTime    @updatedAt @map("updated_at")

  tenant          Tenant                    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  categories      ProductCategory[]
  variants        ProductVariant[]
  kitComponents   ProductComponent[]        @relation("ParentProduct")
  componentOfKits ProductComponent[]        @relation("ChildProduct")
  inventoryItems  InventoryItem[]
  inventoryTx     InventoryTransaction[]
  poItems         PurchaseOrderItem[]
  orderItems      OrderItem[]
  returnItems     ReturnItem[]
  adjustmentItems InventoryAdjustmentItem[]
  transferItems   InventoryTransferItem[]
  stockCountItems StockCountItem[]

  @@unique([tenantId, sku]) // SKU unique per tenant
  @@index([tenantId])
  @@index([name]) // Index name for searching
  @@index([isActive])
  @@map("products")
}

model ProductCategory {
  productId  String   @map("product_id")
  categoryId String   @map("category_id")
  assignedAt DateTime @default(now()) @map("assigned_at")

  product  Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@id([productId, categoryId])
  @@index([categoryId])
  @@map("product_categories")
}

model ProductVariant {
  id               String   @id @default(uuid())
  tenantId         String   @map("tenant_id")
  productId        String   @map("product_id")
  sku              String   // Variant-specific SKU
  upc              String?
  ean              String?
  name             String?  // Auto-generated or specific variant name
  attributes       Json     // e.g., { "color": "Red", "size": "Large" }
  priceModifier    Decimal  @default(0) @map("price_modifier") @db.Decimal(19, 4)
  costModifier     Decimal  @default(0) @map("cost_modifier") @db.Decimal(19, 4)
  weightModifier   Decimal  @default(0) @map("weight_modifier") @db.Decimal(10, 4)
  customAttributes Json?    @default("{}") @map("custom_attributes")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([productId, sku]) // Variant SKU unique per base product
  @@index([tenantId])
  // @@index([attributes], type: Gin) // Consider adding GIN index if querying attributes heavily
  @@map("product_variants")
}

model ProductComponent {
  id              String   @id @default(uuid())
  tenantId        String   @map("tenant_id")
  parentProductId String   @map("parent_product_id") // The Kit/Bundle product
  childProductId  String   @map("child_product_id") // The component product
  quantity        Decimal  @db.Decimal(10, 4)      // Quantity of child needed for 1 parent
  createdAt       DateTime @default(now()) @map("created_at")

  parentProduct Product @relation("ParentProduct", fields: [parentProductId], references: [id], onDelete: Cascade) // If kit deleted, component links deleted
  childProduct  Product @relation("ChildProduct", fields: [childProductId], references: [id], onDelete: Restrict) // Prevent deleting product if it's a component
  @@unique([parentProductId, childProductId])
  @@index([tenantId])
  @@index([childProductId])
  @@map("product_components")
}

// --- Inventory Models ---
model Location {
  id               String       @id @default(uuid())
  tenantId         String       @map("tenant_id")
  parentLocationId String?      @map("parent_location_id")
  name             String
  address          Json?
  locationType     LocationType @default(STORE) @map("location_type")
  isActive         Boolean      @default(true) @map("is_active")
  createdAt        DateTime     @default(now()) @map("created_at")
  updatedAt        DateTime     @updatedAt @map("updated_at")

  tenant               Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  parentLocation       Location?              @relation("LocationHierarchy", fields: [parentLocationId], references: [id], onDelete: SetNull) // Don't delete children if parent deleted
  subLocations         Location[]             @relation("LocationHierarchy")
  inventoryItems       InventoryItem[]
  inventoryTx          InventoryTransaction[]
  sourceTransfers      InventoryTransfer[]    @relation("SourceLocation")
  destTransfers        InventoryTransfer[]    @relation("DestinationLocation")
  inventoryAdjustments InventoryAdjustment[]
  purchaseOrders       PurchaseOrder[]        // Delivery location
  orders               Order[]                // Fulfillment location
  posSessions          PosSession[]
  returnRestockItems   ReturnItem[]           // Restock location
  returns              Return[]               // Location where return was processed
  stockCounts          StockCount[]

  @@unique([tenantId, name]) // Location name unique per tenant
  @@index([tenantId])
  @@index([parentLocationId])
  @@index([isActive])
  @@map("locations")
}

model InventoryItem {
  id                String    @id @default(uuid())
  tenantId          String    @map("tenant_id")
  productId         String    @map("product_id")
  locationId        String    @map("location_id")
  quantityOnHand    Decimal   @default(0) @map("quantity_on_hand") @db.Decimal(19, 4)
  quantityAllocated Decimal   @default(0) @map("quantity_allocated") @db.Decimal(19, 4)
  quantityIncoming  Decimal   @default(0) @map("quantity_incoming") @db.Decimal(19, 4)
  reorderPoint      Decimal?  @map("reorder_point") @db.Decimal(19, 4)
  reorderQuantity   Decimal?  @map("reorder_quantity") @db.Decimal(19, 4)
  abcCategory       String?   @map("abc_category") @db.Char(1)
  lastCountedAt     DateTime? @map("last_counted_at")
  averageCost       Decimal?  @map("average_cost") @db.Decimal(19, 4)
  customAttributes  Json?     @default("{}") @map("custom_attributes")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  tenant   Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  product  Product           @relation(fields: [productId], references: [id], onDelete: Cascade) // If product deleted, stock level record deleted
  location Location          @relation(fields: [locationId], references: [id], onDelete: Cascade) // If location deleted, stock level record deleted
  details  InventoryDetail[]

  @@unique([tenantId, productId, locationId]) // Unique stock record per product per location per tenant
  @@index([tenantId])
  @@index([productId])
  @@index([locationId])
  @@index([updatedAt])
  @@map("inventory_items")
}

model InventoryDetail {
  id                String    @id @default(uuid())
  tenantId          String    @map("tenant_id")
  inventoryItemId   String    @map("inventory_item_id")
  lotNumber         String?   @map("lot_number")
  serialNumber      String?   @map("serial_number")
  expiryDate        DateTime? @map("expiry_date") @db.Date
  quantity          Decimal   @db.Decimal(19, 4) // Quantity for this specific lot/serial/expiry instance
  unitCost          Decimal?  @map("unit_cost") @db.Decimal(19, 4)
  receivedAt        DateTime  @default(now()) @map("received_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  inventoryItem InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade) // Delete details if parent item deleted

  @@unique([tenantId, serialNumber], name: "unique_tenant_serial") // Serial unique per tenant (if not null)
  @@index([inventoryItemId])
  @@index([tenantId])
  @@index([lotNumber])
  @@index([serialNumber]) // Index for searching serials
  @@index([expiryDate]) // Index for finding expiring items
  @@map("inventory_details")
}

model InventoryTransaction {
  id                  BigInt                   @id @default(autoincrement()) @map("transaction_id") // Use BigInt for high volume
  tenantId            String                   @map("tenant_id")
  timestamp           DateTime                 @default(now())
  productId           String                   @map("product_id")
  locationId          String                   @map("location_id")
  transactionType     InventoryTransactionType @map("transaction_type")
  quantityChange      Decimal                  @map("quantity_change") @db.Decimal(19, 4)
  unitCost            Decimal?                 @map("unit_cost") @db.Decimal(19, 4)
  lotNumber           String?                  @map("lot_number")
  serialNumber        String?                  @map("serial_number")
  expiryDate          DateTime?                @map("expiry_date") @db.Date
  relatedOrderId      String?                  @map("related_order_id")
  relatedOrderItemId  String?                  @map("related_order_item_id")
  relatedPoId         String?                  @map("related_po_id")
  relatedPoItemId     String?                  @map("related_po_item_id")
  relatedTransferId   String?                  @map("related_transfer_id")
  relatedAdjustmentId String?                  @map("related_adjustment_id")
  relatedReturnItemId String?                  @map("related_return_item_id")
  userId              String?                  @map("user_id")
  notes               String?

  tenant              Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  product             Product              @relation(fields: [productId], references: [id], onDelete: Restrict) // Keep transactions even if product deleted
  location            Location             @relation(fields: [locationId], references: [id], onDelete: Restrict) // Keep transactions even if location deleted
  order               Order?               @relation(fields: [relatedOrderId], references: [id], onDelete: SetNull)
  orderItem           OrderItem?           @relation(fields: [relatedOrderItemId], references: [id], onDelete: SetNull)
  purchaseOrder       PurchaseOrder?       @relation(fields: [relatedPoId], references: [id], onDelete: SetNull)
  purchaseOrderItem   PurchaseOrderItem?   @relation(fields: [relatedPoItemId], references: [id], onDelete: SetNull)
  inventoryTransfer   InventoryTransfer?   @relation(fields: [relatedTransferId], references: [id], onDelete: SetNull)
  inventoryAdjustment InventoryAdjustment? @relation(fields: [relatedAdjustmentId], references: [id], onDelete: SetNull)
  returnItem          ReturnItem?          @relation(fields: [relatedReturnItemId], references: [id], onDelete: SetNull)
  user                User?                @relation("PerformedByUser", fields: [userId], references: [id], onDelete: SetNull)

  @@index([tenantId, timestamp]) // Partition key candidate
  @@index([tenantId, productId, locationId, timestamp])
  @@index([relatedOrderId])
  @@index([relatedPoId])
  @@index([relatedTransferId])
  @@index([relatedAdjustmentId])
  @@index([userId])
  @@map("inventory_transactions")
}

model InventoryTransfer {
  id                    String         @id @default(uuid())
  tenantId              String         @map("tenant_id")
  sourceLocationId      String         @map("source_location_id")
  destinationLocationId String         @map("destination_location_id")
  status                TransferStatus
  transferDate          DateTime       @default(now()) @map("transfer_date") @db.Date
  estimatedDeliveryDate DateTime?      @map("estimated_delivery_date") @db.Date
  trackingNumber        String?        @map("tracking_number")
  notes                 String?
  createdByUserId       String?        @map("created_by_user_id")
  createdAt             DateTime       @default(now()) @map("created_at")
  updatedAt             DateTime       @updatedAt @map("updated_at")

  tenant                Tenant                  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sourceLocation        Location                @relation("SourceLocation", fields: [sourceLocationId], references: [id], onDelete: Restrict) // Don't delete location if transfers exist
  destinationLocation   Location                @relation("DestinationLocation", fields: [destinationLocationId], references: [id], onDelete: Restrict) // Don't delete location if transfers exist
  createdByUser         User?                   @relation("CreatedByUser", fields: [createdByUserId], references: [id], onDelete: SetNull)
  items                 InventoryTransferItem[]
  inventoryTransactions InventoryTransaction[]

  @@index([tenantId])
  @@index([status])
  @@index([sourceLocationId])
  @@index([destinationLocationId])
  @@map("inventory_transfers")
}

model InventoryTransferItem {
  id                String  @id @default(uuid())
  tenantId          String  @map("tenant_id")
  transferId        String  @map("transfer_id")
  productId         String  @map("product_id")
  quantityRequested Decimal @map("quantity_requested") @db.Decimal(19, 4)
  quantityShipped   Decimal @default(0) @map("quantity_shipped") @db.Decimal(19, 4)
  quantityReceived  Decimal @default(0) @map("quantity_received") @db.Decimal(19, 4)
  lotNumber         String? @map("lot_number")
  serialNumber      String? @map("serial_number")

  transfer InventoryTransfer @relation(fields: [transferId], references: [id], onDelete: Cascade) // Delete items if transfer deleted
  product  Product           @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@index([transferId])
  @@index([productId])
  @@index([tenantId])
  @@map("inventory_transfer_items")
}

model InventoryAdjustment {
  id              String   @id @default(uuid())
  tenantId        String   @map("tenant_id")
  locationId      String   @map("location_id")
  adjustmentDate  DateTime @default(now()) @map("adjustment_date") @db.Date
  reasonCode      String?  @map("reason_code")
  notes           String?
  createdByUserId String?  @map("created_by_user_id")
  createdAt       DateTime @default(now()) @map("created_at")

  tenant                Tenant                    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  location              Location                  @relation(fields: [locationId], references: [id], onDelete: Restrict)
  createdByUser         User?                     @relation("CreatedByUser", fields: [createdByUserId], references: [id], onDelete: SetNull)
  items                 InventoryAdjustmentItem[]
  inventoryTransactions InventoryTransaction[]

  @@index([tenantId])
  @@index([locationId])
  @@index([adjustmentDate])
  @@map("inventory_adjustments")
}

model InventoryAdjustmentItem {
  id             String   @id @default(uuid())
  tenantId       String   @map("tenant_id")
  adjustmentId   String   @map("adjustment_id")
  productId      String   @map("product_id")
  quantityChange Decimal  @map("quantity_change") @db.Decimal(19, 4)
  unitCost       Decimal? @map("unit_cost") @db.Decimal(19, 4)
  lotNumber      String?  @map("lot_number")
  serialNumber   String?  @map("serial_number")

  adjustment InventoryAdjustment @relation(fields: [adjustmentId], references: [id], onDelete: Cascade)
  product    Product             @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@index([adjustmentId])
  @@index([productId])
  @@index([tenantId])
  @@map("inventory_adjustment_items")
}


// --- Supplier & Purchasing Models ---
model Supplier {
  id               String   @id @default(uuid())
  tenantId         String   @map("tenant_id")
  name             String
  contactName      String?  @map("contact_name")
  email            String?
  phone            String?
  address          Json?
  paymentTerms     String?  @map("payment_terms")
  isActive         Boolean  @default(true) @map("is_active")
  customAttributes Json?    @default("{}") @map("custom_attributes")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  tenant         Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  purchaseOrders PurchaseOrder[]

  @@unique([tenantId, name])
  @@index([tenantId])
  @@index([isActive])
  @@map("suppliers")
}

model PurchaseOrder {
  id                   String              @id @default(uuid())
  tenantId             String              @map("tenant_id")
  poNumber             String              @map("po_number")
  supplierId           String              @map("supplier_id")
  locationId           String              @map("location_id") // Delivery location
  status               PurchaseOrderStatus
  orderDate            DateTime            @default(now()) @map("order_date") @db.Date
  expectedDeliveryDate DateTime?           @map("expected_delivery_date") @db.Date
  notes                String?
  shippingCost         Decimal             @default(0) @map("shipping_cost") @db.Decimal(19, 4)
  subtotal             Decimal             @default(0) @db.Decimal(19, 4)
  taxAmount            Decimal             @default(0) @map("tax_amount") @db.Decimal(19, 4)
  totalAmount          Decimal             @default(0) @map("total_amount") @db.Decimal(19, 4)
  createdByUserId      String?             @map("created_by_user_id")
  createdAt            DateTime            @default(now()) @map("created_at")
  updatedAt            DateTime            @updatedAt @map("updated_at")

  tenant                Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  supplier              Supplier               @relation(fields: [supplierId], references: [id], onDelete: Restrict)
  location              Location               @relation(fields: [locationId], references: [id], onDelete: Restrict)
  createdByUser         User?                  @relation("CreatedByUser", fields: [createdByUserId], references: [id], onDelete: SetNull)
  items                 PurchaseOrderItem[]
  inventoryTransactions InventoryTransaction[]

  @@unique([tenantId, poNumber])
  @@index([tenantId])
  @@index([supplierId])
  @@index([locationId])
  @@index([status])
  @@index([orderDate])
  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id               String    @id @default(uuid())
  tenantId         String    @map("tenant_id")
  poId             String    @map("po_id")
  productId        String    @map("product_id")
  description      String?
  quantityOrdered  Decimal   @map("quantity_ordered") @db.Decimal(19, 4)
  quantityReceived Decimal   @default(0) @map("quantity_received") @db.Decimal(19, 4)
  unitCost         Decimal   @map("unit_cost") @db.Decimal(19, 4)
  taxRate          Decimal   @default(0) @map("tax_rate") @db.Decimal(5, 4)
  taxAmount        Decimal   @default(0) @map("tax_amount") @db.Decimal(19, 4)
  lineTotal        Decimal   @map("line_total") @db.Decimal(19, 4) // Calculated = quantityOrdered * unitCost (before tax)
  receivedAt       DateTime? @map("received_at")
  notes            String?

  purchaseOrder         PurchaseOrder          @relation(fields: [poId], references: [id], onDelete: Cascade)
  product               Product                @relation(fields: [productId], references: [id], onDelete: Restrict)
  inventoryTransactions InventoryTransaction[]

  @@index([poId])
  @@index([productId])
  @@index([tenantId])
  @@map("purchase_order_items")
}


// --- Customer Models ---
model CustomerGroup {
  id          String   @id @default(uuid())
  tenantId    String   @map("tenant_id")
  name        String
  description String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  tenant    Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customers Customer[]

  @@unique([tenantId, name])
  @@index([tenantId])
  @@map("customer_groups")
}

model Customer {
  id                     String   @id @default(uuid())
  tenantId               String   @map("tenant_id")
  firstName              String?  @map("first_name")
  lastName               String?  @map("last_name")
  email                  String?
  phone                  String?
  companyName            String?  @map("company_name")
  loyaltyPoints          Int      @default(0) @map("loyalty_points")
  customerGroupId        String?  @map("customer_group_id")
  defaultBillingAddress  Json?    @map("default_billing_address")
  defaultShippingAddress Json?    @map("default_shipping_address")
  taxExempt              Boolean  @default(false) @map("tax_exempt")
  notes                  String?
  customAttributes       Json?    @default("{}") @map("custom_attributes")
  createdAt              DateTime @default(now()) @map("created_at")
  updatedAt              DateTime @updatedAt @map("updated_at")
  // Add isActive for customers? useful for disabling ordering
  // isActive              Boolean @default(true)

  tenant        Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customerGroup CustomerGroup? @relation(fields: [customerGroupId], references: [id], onDelete: SetNull)
  orders        Order[]
  returns       Return[]       // Link returns back to customer

  @@unique([tenantId, email], name: "unique_tenant_email") // Enforce unique email per tenant if not null
  @@index([tenantId])
  @@index([email])
  @@index([customerGroupId])
  @@map("customers")
}


// --- Order & POS Models ---
model Order {
  id                     String      @id @default(uuid())
  tenantId               String      @map("tenant_id")
  orderNumber            String      @map("order_number")
  customerId             String?     @map("customer_id")
  locationId             String      @map("location_id")
  posTerminalId          String?     @map("pos_terminal_id")
  userId                 String?     @map("user_id") // Salesperson/creator
  orderType              OrderType   @default(POS) @map("order_type")
  status                 OrderStatus
  orderDate              DateTime    @default(now()) @map("order_date")
  subtotal               Decimal     @db.Decimal(19, 4)
  discountAmount         Decimal     @default(0) @map("discount_amount") @db.Decimal(19, 4) // Order-level discount
  taxAmount              Decimal     @default(0) @map("tax_amount") @db.Decimal(19, 4) // Total order tax
  shippingCost           Decimal     @default(0) @map("shipping_cost") @db.Decimal(19, 4)
  totalAmount            Decimal     @map("total_amount") @db.Decimal(19, 4) // Grand total
  currencyCode           String      @map("currency_code") @db.Char(3)
  notes                  String?
  shippingAddress        Json?       @map("shipping_address")
  shippingMethod         String?     @map("shipping_method")
  trackingNumber         String?     @map("tracking_number")
  customAttributes       Json?       @default("{}") @map("custom_attributes")
  isBackordered          Boolean     @default(false) @map("is_backordered")
  createdAt              DateTime    @default(now()) @map("created_at")
  updatedAt              DateTime    @updatedAt @map("updated_at")

  tenant                 Tenant                  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer               Customer?               @relation(fields: [customerId], references: [id], onDelete: SetNull) // Keep order if customer deleted
  location               Location                @relation(fields: [locationId], references: [id], onDelete: Restrict) // Prevent location delete if orders exist
  user                   User?                   @relation("CreatedByUser", fields: [userId], references: [id], onDelete: SetNull)
  items                  OrderItem[]
  payments               Payment[]               // Payments made for this order
  inventoryTransactions  InventoryTransaction[]
  initiatedReturns       Return[]                @relation("OriginalOrderReturns") // Returns *initiated from* this order
  returnForExchange      Return?                 @relation("ExchangeOrderReturn") // If this order *is* an exchange *for* a return
  posSessionTransactions PosSessionTransaction[] // Cash transactions linked to this order

  @@unique([tenantId, orderNumber])
  @@index([tenantId])
  @@index([customerId])
  @@index([locationId])
  @@index([userId])
  @@index([status])
  @@index([orderDate])
  @@map("orders")
}

model OrderItem {
  id                  String   @id @default(uuid())
  tenantId            String   @map("tenant_id")
  orderId             String   @map("order_id")
  productId           String   @map("product_id")
  productSnapshot     Json?    @map("product_snapshot")
  quantity            Decimal  @db.Decimal(19, 4)
  unitPrice           Decimal  @map("unit_price") @db.Decimal(19, 4) // Price after item discount
  originalUnitPrice   Decimal? @map("original_unit_price") @db.Decimal(19, 4) // Price before discount
  discountAmount      Decimal  @default(0) @map("discount_amount") @db.Decimal(19, 4) // Item-level discount amount
  taxAmount           Decimal  @default(0) @map("tax_amount") @db.Decimal(19, 4)
  taxRate             Decimal  @default(0) @map("tax_rate") @db.Decimal(5, 4)
  lineTotal           Decimal  @map("line_total") @db.Decimal(19, 4) // (unitPrice * quantity) - Could be pre-tax or post-tax depending on definition
  lotNumber           String?  @map("lot_number")
  serialNumber        String?  @map("serial_number")
  quantityReturned    Decimal  @default(0) @map("quantity_returned") @db.Decimal(19, 4) // Tracks returned qty for this specific line
  notes               String?
  customAttributes    Json?    @default("{}") @map("custom_attributes")

  order                 Order                  @relation(fields: [orderId], references: [id], onDelete: Cascade) // Delete item if order deleted
  product               Product                @relation(fields: [productId], references: [id], onDelete: Restrict) // Prevent product delete if on orders
  inventoryTransactions InventoryTransaction[] // Link stock deductions
  returnItems           ReturnItem[]           // Link returns back to this item

  @@index([orderId])
  @@index([productId])
  @@index([tenantId])
  @@map("order_items")
}

model Payment {
  id                   String        @id @default(uuid())
  tenantId             String        @map("tenant_id")
  orderId              String?       @map("order_id") // Potentially nullable if payment can exist without direct order (e.g., deposit) - Made required by FK below
  paymentMethod        PaymentMethod @map("payment_method")
  amount               Decimal       @db.Decimal(19, 4) // Positive for payment, could be negative for manual refund entry?
  currencyCode         String        @map("currency_code") @db.Char(3)
  status               PaymentStatus
  transactionReference String?       @map("transaction_reference")
  paymentDetails       Json?         @map("payment_details")
  paymentDate          DateTime      @default(now()) @map("payment_date")
  processedByUserId    String?       @map("processed_by_user_id")
  notes                String?
  returnId             String?       // Link to Return if this is a Refund payment
  createdAt            DateTime    @default(now()) @map("created_at")

  order           Order? @relation(fields: [orderId], references: [id], onDelete: Cascade) // Make order required via FK, but field optional? No, needs orderId.
  // Let's assume Payment always links to an Order or a Return, not both. If linked to Return, orderId might be null.
  // Revised: Keep orderId required for payments, refunds are separate records or status updates.
  // To link refund payments back: add optional field on Payment `refundedPaymentId String?`? Or use the `returnId` field.
  // Using `returnId` field implies this Payment record *is* the refund.

  processedByUser User?   @relation("ProcessedByUser", fields: [processedByUserId], references: [id], onDelete: SetNull)
  return          Return? @relation("RefundPayments", fields: [returnId], references: [id], onDelete: SetNull) // Link to Return if this is a refund payment

  @@index([orderId])
  @@index([returnId]) // Index for finding refund payments for a return
  @@index([status])
  @@index([paymentMethod])
  @@index([paymentDate])
  @@index([tenantId])
  @@map("payments")
}

// --- Return Models ---
model Return {
  id                String       @id @default(uuid())
  tenantId          String       @map("tenant_id")
  returnNumber      String?      @unique @map("return_number") // Optional: Auto-generate a return number
  originalOrderId   String       @map("original_order_id")
  returnOrderId     String?      @unique @map("return_order_id") // Link to a new Order if this was an exchange
  returnDate        DateTime     @default(now()) @map("return_date")
  reason            String?
  processedByUserId String?      @map("processed_by_user_id")
  totalRefundAmount Decimal?     @map("total_refund_amount") @db.Decimal(19, 4) // Calculated sum of refund payments
  locationId        String       @map("location_id") // Location where return was processed
  customerId        String?      @map("customer_id")
  status            ReturnStatus
  createdAt       DateTime     @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  tenant          Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  originalOrder   Order        @relation("OriginalOrderReturns", fields: [originalOrderId], references: [id], onDelete: Restrict)
  exchangeOrder   Order?       @relation("ExchangeOrderReturn", fields: [returnOrderId], references: [id], onDelete: SetNull)
  processedByUser User?        @relation("CreatedByUser", fields: [processedByUserId], references: [id], onDelete: SetNull)
  location        Location     @relation(fields: [locationId], references: [id], onDelete: Restrict) // Don't delete location if returns exist
  customer        Customer?    @relation(fields: [customerId], references: [id], onDelete: SetNull) // Keep return if customer deleted
  items           ReturnItem[] // Items included in this return
  refundPayments  Payment[]    @relation("RefundPayments") // Refund payments issued for this return

  @@index([tenantId])
  @@index([originalOrderId])
  @@index([returnOrderId])
  @@index([locationId])
  @@index([customerId])
  @@index([status])
  @@map("returns")
}

model ReturnItem {
  id                  String               @id @default(uuid())
  tenantId            String               @map("tenant_id")
  returnId            String               @map("return_id")
  originalOrderItemId String?              @map("original_order_item_id") // Link back to original line item if possible
  productId           String               @map("product_id")
  quantity            Decimal              @db.Decimal(19, 4) // Quantity being returned
  unitRefundAmount    Decimal?             @map("unit_refund_amount") @db.Decimal(19, 4) // Actual price refunded per unit
  lineRefundAmount    Decimal?             @map("line_refund_amount") @db.Decimal(19, 4) // Optional: Calculated total refund for line
  condition           ReturnItemCondition? // Condition upon return
  restock             Boolean              @default(false) // Flag indicating if item was decided to be restocked
  restockLocationId   String?              @map("restock_location_id") // Where it was restocked (if restock=true and condition=SELLABLE)
  lotNumber           String?              @map("lot_number")
  serialNumber        String?              @map("serial_number")

  returnRequest         Return                 @relation(fields: [returnId], references: [id], onDelete: Cascade) // Delete item if Return header deleted
  originalOrderItem     OrderItem?             @relation(fields: [originalOrderItemId], references: [id], onDelete: SetNull) // Keep return item even if original OrderItem deleted
  product               Product                @relation(fields: [productId], references: [id], onDelete: Restrict) // Prevent product delete if in returns
  restockLocation       Location?              @relation(fields: [restockLocationId], references: [id], onDelete: Restrict) // Don't delete location if used for restock here
  inventoryTransactions InventoryTransaction[] // Link restock/dispose inventory transactions

  @@index([returnId])
  @@index([originalOrderItemId])
  @@index([productId])
  @@index([tenantId])
  @@map("return_items")
}


// --- POS Session Models ---
model PosSession {
  id             String           @id @default(uuid())
  tenantId       String           @map("tenant_id")
  locationId     String           @map("location_id")
  posTerminalId  String           @map("pos_terminal_id")
  userId         String           @map("user_id")
  startTime      DateTime         @default(now()) @map("start_time")
  endTime        DateTime?        @map("end_time")
  startingCash   Decimal          @map("starting_cash") @db.Decimal(19, 4)
  endingCash     Decimal?         @map("ending_cash") @db.Decimal(19, 4)
  calculatedCash Decimal?         @map("calculated_cash") @db.Decimal(19, 4)
  difference     Decimal?         @db.Decimal(19, 4)
  status         PosSessionStatus
  notes          String?

  tenant       Tenant                  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  location     Location                @relation(fields: [locationId], references: [id], onDelete: Restrict)
  user         User                    @relation("ManagedByUser", fields: [userId], references: [id], onDelete: Restrict)
  transactions PosSessionTransaction[]

  @@index([tenantId])
  @@index([locationId])
  @@index([userId])
  @@index([status])
  @@index([startTime])
  @@index([posTerminalId]) // Index for finding sessions by terminal
  @@map("pos_sessions")
}

model PosSessionTransaction {
  id              String             @id @default(uuid())
  tenantId        String             @map("tenant_id")
  posSessionId    String             @map("pos_session_id")
  timestamp       DateTime           @default(now())
  transactionType PosTransactionType @map("transaction_type")
  amount          Decimal            @db.Decimal(19, 4) // Always positive; type determines direction (+/-)
  relatedOrderId  String?            @map("related_order_id")
  notes           String?

  posSession PosSession @relation(fields: [posSessionId], references: [id], onDelete: Cascade) // Delete tx if session deleted
  order      Order?     @relation(fields: [relatedOrderId], references: [id], onDelete: SetNull) // Keep tx even if order deleted

  @@index([posSessionId])
  @@index([timestamp])
  @@index([tenantId])
  @@index([relatedOrderId])
  @@map("pos_session_transactions")
}


// --- Config & Audit Models ---
model Configuration {
  id          String   @id @default(uuid())
  tenantId    String?  @map("tenant_id")
  configKey   String   @map("config_key")
  configValue Json     @map("config_value")
  description String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  tenant Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, configKey])
  @@index([tenantId])
  @@index([configKey])
  @@map("configurations")
}

model NotificationTemplate {
  id           String           @id @default(uuid())
  tenantId     String           @map("tenant_id")
  templateName String           @map("template_name")
  templateType NotificationType @map("template_type")
  eventTrigger String           @map("event_trigger")
  subject      String?
  body         String
  isActive     Boolean          @default(true) @map("is_active")
  createdAt    DateTime         @default(now()) @map("created_at")
  updatedAt    DateTime         @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, templateName])
  @@index([tenantId])
  @@index([eventTrigger])
  @@map("notification_templates")
}

model AuditLog {
  id         BigInt    @id @default(autoincrement()) @map("log_id")
  tenantId   String?   @map("tenant_id")
  timestamp  DateTime  @default(now()) @db.Timestamp(6) // Increased precision for logs
  userId     String?   @map("user_id")
  action     String
  entityType String?   @map("entity_type")
  entityId   String?   @map("entity_id")
  details    Json?
  ipAddress  String?   @map("ip_address")
  userAgent  String?   @map("user_agent")

  tenant Tenant? @relation(fields: [tenantId], references: [id], onDelete: SetNull) // Keep log if tenant deleted
  user   User?   @relation("ActionByUser", fields: [userId], references: [id], onDelete: SetNull) // Keep log if user deleted

  @@index([tenantId, timestamp]) // Partition key candidate
  @@index([userId])
  @@index([entityType, entityId])
  @@index([action]) // Index action for filtering specific event types
  @@map("audit_logs")
}

// --- NEW Models for Stock Count ---

model StockCount {
  id                String           @id @default(uuid())
  tenantId          String           @map("tenant_id")
  locationId        String           @map("location_id")
  countNumber       String?          @unique @map("count_number") // Optional: Auto-generated count identifier
  status            StockCountStatus @default(PENDING)
  type              StockCountType   // FULL or CYCLE
  initiatedByUserId String           @map("initiated_by_user_id")
  initiatedAt       DateTime         @default(now()) @map("initiated_at")
  reviewedByUserId  String?          @map("reviewed_by_user_id")
  reviewedAt        DateTime?        @map("reviewed_at")
  completedByUserId String?          @map("completed_by_user_id") // User who posted adjustments
  completedAt       DateTime?        @map("completed_at")
  notes             String?
  createdAt         DateTime         @default(now()) @map("created_at")
  updatedAt         DateTime         @updatedAt @map("updated_at")

  tenant          Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  location        Location           @relation(fields: [locationId], references: [id], onDelete: Restrict) // Don't delete location if counts exist
  initiatedByUser User               @relation("InitiatedStockCounts", fields: [initiatedByUserId], references: [id], onDelete: Restrict)
  reviewedByUser  User?              @relation("ReviewedStockCounts", fields: [reviewedByUserId], references: [id], onDelete: SetNull)
  completedByUser User?              @relation("CompletedStockCounts", fields: [completedByUserId], references: [id], onDelete: SetNull)
  items           StockCountItem[]

  @@index([tenantId])
  @@index([locationId])
  @@index([status])
  @@index([type])
  @@index([initiatedAt])
  @@map("stock_counts")
}

model StockCountItem {
  id                  String                @id @default(uuid())
  tenantId            String                @map("tenant_id")
  stockCountId        String                @map("stock_count_id")
  productId           String                @map("product_id")
  snapshotQuantity    Decimal               @map("snapshot_quantity") @db.Decimal(19, 4) // QOH at initiation
  countedQuantity     Decimal?              @map("counted_quantity") @db.Decimal(19, 4) // Entered by user
  varianceQuantity    Decimal?              @map("variance_quantity") @db.Decimal(19, 4) // Calculated: counted - snapshot
  unitCostAtSnapshot  Decimal?              @map("unit_cost_at_snapshot") @db.Decimal(19, 4) // For variance valuation
  status              StockCountItemStatus  @default(PENDING)
  countedByUserId     String?               @map("counted_by_user_id")
  countedAt           DateTime?             @map("counted_at")
  reviewNotes         String?               @map("review_notes") // Notes from the reviewer
  // Optional: Add fields for lot/serial if counting specific instances
  lotNumber           String?
  notes               String?
  serialNumber        String?
  createdAt           DateTime              @default(now()) @map("created_at")
  updatedAt           DateTime              @updatedAt @map("updated_at")


  stockCount      StockCount         @relation(fields: [stockCountId], references: [id], onDelete: Cascade) // Delete items if count deleted
  product         Product            @relation(fields: [productId], references: [id], onDelete: Restrict) // Don't delete product if on count sheet
  countedByUser   User?              @relation("CountedStockCountItems", fields: [countedByUserId], references: [id], onDelete: SetNull)

  @@unique([stockCountId, productId , lotNumber, serialNumber]) // Ensure only one line per product (or product/lot/serial) per count
  @@index([tenantId]) // Index tenantId for direct queries if needed
  @@index([stockCountId])
  @@index([productId])
  @@index([status])
  @@map("stock_count_items")
}
